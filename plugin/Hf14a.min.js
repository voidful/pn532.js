!function(t,a){"object"==typeof exports&&"undefined"!=typeof module?module.exports=a(require("lodash")):"function"==typeof define&&define.amd?define(["lodash"],a):(t="undefined"!=typeof globalThis?globalThis:t||self).Pn532Hf14a=a(t._)}(this,(function(t){"use strict";return class{name="hf14a";install(a,e){const{Packet:r,pn532:i,utils:n}=a,{retry:o}=n;function c(){return i?.$adapter?.isOpen?.()}async function s({maxTg:a=1,uid:e=new r,timeout:n}={}){const o=new r([136]);7===e.length?e=r.merge(o,e):10===e.length&&(e=r.merge(o,e.subarray(0,3),o,e.subarray(3)));const{data:c}=await i.inListPassiveTarget({maxTg:a,brTy:0,data:e,timeout:n}),s=t.times(c[0],(()=>({})));if(!t.find([0,8,12,10,14,11,15],(a=>{try{const e=t.map((16+a).toString(2).slice(-4),t.parseInt);if(e[0]+e[2]!==s.length)return!1;let r=1;for(let a=0;a<s.length;a++){const i=s[a];if(i.pack=c.subarray(r),i.pack[0]!==a+1)return!1;const n=i.pack[4];if(!t.includes([4,7,10],n))return!1;const o=e[2*a+1]?i.pack[5+n]:0,w=5+n+e[2*a+1]+o;if(i.pack=i.pack.subarray(0,w),i.atqa=i.pack.subarray(1,3),i.sak=i.pack.subarray(3,4),i.uid=i.pack.subarray(5,5+n),i.rats=i.pack.subarray(6+n),i.rats.length!==o)return!1;r+=w}return!0}catch(t){return!1}})))throw new Error("invalid hf14a target format");return s}async function w(){c()&&await i.inRelease().catch((()=>{}))}async function l({block:t=0,isKb:a=0,key:e,tg:n=1,uid:o,blocksPerSector:c=4}={}){if(!r.isLen(e,6))throw new TypeError("invalid key");if(!r.isLen(o,4))throw new TypeError("invalid uid");a=a?1:0,t+=c-t%c-1;try{await i.inDataExchange({tg:n,data:new r([96+a,t,...e,...o])})}catch(a){throw new Error(`Failed to auth block ${t}`)}}function d(a){const e=t.flatten(t.times(3,(t=>[(240&a[t])>>4,15&a[t]])));return t.every([[1,2],[0,5],[3,4]],(([t,a])=>e[t]^15===e[a]))}function y(a){if(!t.isArray(a))throw new TypeError("invalid keys");return t.chain(a).filter((t=>r.isLen(t,6))).uniqWith(((t,a)=>t.isEqual(a))).value()}async function f(t,a){return(await o((async()=>{try{return await i.inDataExchange(t)}catch(e){if(!c())throw e;throw await i.inDeselect({tg:1}).catch((()=>{})),await l(a).catch((()=>{})),new Error(`Failed to read block ${t?.data?.[1]}`)}})))?.data}function u(t){return 0!==t.data[0]||r.isLen(t.data,17)}async function k(t,a){await o((async()=>{try{await i.inDataExchange(t)}catch(e){if(!c())throw e;throw await i.inDeselect({tg:1}).catch((()=>{})),await l(a).catch((()=>{})),new Error(`Failed to write block ${t?.data?.[1]}`)}}))}async function h(t,a,e){await o((async()=>{try{await l(a),await i.inDataExchange({data:t}),a.block!==e.block&&a.isKb===e.isKb&&await l(e),await i.inDataExchange({data:new r([176,e.block])})}catch(r){if(!c())throw r;await i.inDeselect({tg:1}).catch((()=>{}));const n={160:"write",176:"transfer",192:"decrement",193:"increment",194:"restore"}[t?.[0]]??`cmd(0x${t?.subarray(0,1)?.hex})`;throw new Error(`Failed to ${n} block from ${a.block} to ${e.block}`)}}))}async function b(){try{await s(),await i.inSelect({tg:1}),await i.writeRegisters({25346:0,25347:0}),await i.inCommunicateThru({data:new r([80,0,87,205])}).catch((()=>{})),await i.writeRegisters({25405:7}),await i.inCommunicateThru({data:new r([64])}),await i.writeRegisters({25405:0}),await i.inCommunicateThru({data:new r([67])})}catch(t){if(!c())throw t;throw new Error("Failed to open backdoor")}finally{c()&&await i.writeRegisters({25346:128,25347:128})}}async function m(t){return(await o((async()=>{try{return await i.inDataExchange(t)}catch(a){throw await w(),await b().catch((()=>{})),new Error(`Failed to read block ${t?.data?.[1]}`)}})))?.data}async function E(t){await o((async()=>{try{await i.inDataExchange(t)}catch(a){throw await w(),await b().catch((()=>{})),new Error(`Failed to write block ${t?.data?.[1]}`)}}))}async function p({block:t=0,data:a}={}){if(!r.isLen(a,16))throw new TypeError("invalid data");try{await b(),await E({data:new r([160,t,...a])})}finally{await w()}}return{inListPassiveTarget:s,mfAuthBlock:l,mfBackdoorGen1a:b,mfDecrementBlock:async function({src:t,dist:a,int32:e=0}={}){for(const[e,i]of[["src",t],["dist",a]]){if(!r.isLen(i?.key,6))throw new TypeError(`invalid ${e}.key`);i.isKb=i?.isKb?1:0,i.block=i?.block??0}const i=new r([192,t.block,0,0,0,0]);i.setInt32(2,e);try{const e=(await s())?.[0]?.uid;if(!e)throw new Error("Failed to select card");await h(i,{...t,uid:e},{...a,uid:e})}finally{await w()}},mfIncrementBlock:async function({src:t,dist:a,int32:e=0}={}){for(const[e,i]of[["src",t],["dist",a]]){if(!r.isLen(i?.key,6))throw new TypeError(`invalid ${e}.key`);i.isKb=i?.isKb?1:0,i.block=i?.block??0}const i=new r([193,t.block,0,0,0,0]);i.setInt32(2,e);try{const e=(await s())?.[0]?.uid;if(!e)throw new Error("Failed to select card");await h(i,{...t,uid:e},{...a,uid:e})}finally{await w()}},mfKeysUniq:y,mfReadBlock:async function({block:t=0,isKb:a=0,key:e}={}){if(!r.isLen(e,6))throw new TypeError("invalid key");a=a?1:0;try{const i=(await s())?.[0]?.uid;if(!i)throw new Error("Failed to select card");return await l({block:t,isKb:a,key:e,uid:i}),await f({data:new r([48,t]),respValidator:u},{block:t,isKb:a,key:e,uid:i})}finally{await w()}},mfReadBlockGen1a:async function({block:t=0}={}){try{return await b(),await m({data:new r([48,t]),respValidator:u})}finally{await w()}},mfReadBlockKeyBA:async function({block:t=0,ka:a,kb:e}={}){try{const i=(await s())?.[0]?.uid;if(!i)throw new Error("Failed to select card");for(let n=1;n>=0;n--)try{const o=[a,e][n];return await l({block:t,isKb:n,key:o,uid:i}),await f({data:new r([48,t]),respValidator:u},{block:t,isKb:n,key:o,uid:i})}catch(t){}throw new Error(`Failed to read block ${t}`)}finally{await w()}},mfReadCardByKeys:async function({sectorMax:a=16,keys:e}={}){if(!(e=y(e)).length)throw new TypeError("invalid keys");try{let i=(await s())?.[0]?.uid;if(!i)throw new Error("Failed to select card");const n=new r(64*a),o={key:t.times(2*a,(()=>null)),read:t.times(4*a,(()=>0))};for(let t=0;t<a;t++){for(let a=0;a<2;a++)for(const c of e)try{await l({block:4*t,isKb:a,key:c,uid:i}),o.key[2*t+a]=c;for(let e=0;e<4;e++)try{const s=4*t+e;if(o.read[s])continue;const w=await f({data:new r([48,s]),respValidator:u},{block:4*t,isKb:a,key:c,uid:i});n.set(w,16*s),o.read[s]=1}catch(t){}break}catch(t){await w(),i=(await s())?.[0]?.uid}for(let a=0;a<2;a++)o.key[2*t+a]&&n.set(o.key[2*t+a],64*t+[48,58][a])}return{data:n,success:o}}finally{await w()}},mfReadCardGen1a:async function({sectorMax:a=16}={}){try{await b();const e=new r(64*a),i=t.times(4*a,(()=>0));for(let t=0;t<a;t++)for(let a=0;a<4;a++)try{const n=4*t+a,o=await m({data:new r([48,n]),respValidator:u});e.set(o,16*n),i[n]=1}catch(t){}return{data:e,success:i}}finally{await w()}},mfReadSector:async function({sector:t=0,isKb:a=0,key:e}={}){if(!r.isLen(e,6))throw new TypeError("invalid key");a=a?1:0;try{const i=(await s())?.[0]?.uid;if(!i)throw new Error("Failed to select card");await l({block:4*t,isKb:a,key:e,uid:i});const n=new r(64),o=[0,0,0,0];for(let c=0;c<4;c++)try{const s=4*t+c,w=await f({data:new r([48,s]),respValidator:u},{block:4*t,isKb:a,key:e,uid:i});n.set(w,16*c),o[c]=1}catch(t){}return n.set(e,[48,58][a]),{data:n,success:o}}finally{await w()}},mfReadSectorGen1a:async function({sector:t=0}={}){try{await b();const a=new r(64),e=[0,0,0,0];for(let i=0;i<4;i++)try{const n=4*t+i,o=await m({data:new r([48,n]),respValidator:u});a.set(o,16*i),e[i]=1}catch(t){}return{data:a,success:e}}finally{await w()}},mfReadSectorKeyBA:async function({sector:t=0,ka:a,kb:e}={}){try{const i=new r(64),n={key:[0,0],read:[0,0,0,0]},o=(await s())?.[0]?.uid;if(!o)throw new Error("Failed to select card");for(let c=1;c>=0;c--)try{const s=[a,e][c];await l({block:4*t,isKb:c,key:s,uid:o}),n.key[c]=1;for(let a=0;a<4;a++)try{if(n.read[a])continue;const e=4*t+a,w=await f({data:new r([48,e]),respValidator:u},{block:4*t,isKb:c,key:s,uid:o});i.set(w,16*a),n.read[a]=1}catch(t){}}catch(t){}for(let t=0;t<2;t++)n.key[t]&&i.set([a,e][t],[48,58][t]);return{data:i,success:n}}finally{await w()}},mfRestoreBlock:async function({src:t,dist:a}={}){for(const[e,i]of[["src",t],["dist",a]]){if(!r.isLen(i?.key,6))throw new TypeError(`invalid ${e}.key`);i.isKb=i?.isKb?1:0,i.block=i?.block??0}const e=new r([194,t.block,0,0,0,0]);try{const r=(await s())?.[0]?.uid;if(!r)throw new Error("Failed to select card");await h(e,{...t,uid:r},{...a,uid:r})}finally{await w()}},mfSelectCard:async function(){try{return(await s())?.[0]}finally{await w()}},mfSetUidGen1a:async function({atqa:t=null,sak:a=null,uid:e}={}){if(!r.isLen(e,4))throw new TypeError("invalid 4 bytes uid");const i=r.merge(e,r.fromHex("00080400000000000000BEAF"));for(const t of e)i[4]^=t;r.isLen(a,1)&&i.set(a,5),r.isLen(t,2)&&i.set(t.slice().reverse(),6),await p({block:0,data:i})},mfSetUidGen2:async function({atqa:t=null,sak:a=null,uid:e,keys:i}={}){if(!r.isLen(e,4))throw new TypeError("invalid 4 bytes uid");if(!(i=y(i)).length)throw new TypeError("invalid keys");try{const n=(await s())?.[0]?.uid;if(!n)throw new Error("Failed to select card");const o=r.merge(e,r.fromHex("00080400000000000000BEAF"));for(const t of e)o[4]^=t;r.isLen(a,1)&&o.set(a,5),r.isLen(t,2)&&o.set(t.slice().reverse(),6);let c=!1;for(let t=1;!c&&t>=0;t--){let a;for(const e of i)try{await l({block:0,isKb:t,key:e,uid:n}),a=e;break}catch(t){}if(!a)throw new Error("Failed to auth block 0");try{await k({data:new r([160,0,...o])},{block:0,isKb:t,key:a,uid:n}),c=!0}catch(t){}}if(!c)throw new Error("Failed to write block 0")}finally{await w()}},mfWipeGen1a:async function({sectorMax:a=16,atqa:e=null,sak:i=null,uid:n}={}){try{if(!r.isLen(n,4))throw new TypeError("invalid 4 bytes uid");const o=t.times(4*a,(()=>0));await b();try{const t=r.merge(n,r.fromHex("00080400000000000000BEAF"));for(const a of n)t[4]^=a;r.isLen(i,1)&&t.set(i,5),r.isLen(e,2)&&t.set(e,6),await E({data:new r([160,0,...t])}),o[0]=1}catch(t){}const c=r.fromHex("00000000000000000000000000000000"),s=r.fromHex("FFFFFFFFFFFF08778F00FFFFFFFFFFFF");for(let t=0;t<a;t++){for(let a=t?0:1;a<3;a++)try{await E({data:new r([160,4*t+a,...c])}),o[4*t+a]=1}catch(t){}try{await E({data:new r([160,4*t+3,...s])}),o[4*t+3]=1}catch(t){}}return{success:o}}finally{await w()}},mfWriteBlock:async function({block:t=0,isKb:a=0,key:e,data:i}={}){if(!r.isLen(i,16))throw new TypeError("invalid data");if(!r.isLen(e,6))throw new TypeError("invalid key");a=a?1:0;try{const n=(await s())?.[0]?.uid;if(!n)throw new Error("Failed to select card");await l({block:t,isKb:a,key:e,uid:n}),await k({data:new r([160,t,...i])},{block:t,isKb:a,key:e,uid:n})}finally{await w()}},mfWriteBlockGen1a:p,mfWriteBlockKeyBA:async function({block:t=0,ka:a,kb:e,data:i}={}){if(!r.isLen(i,16))throw new TypeError("invalid data");let n=!1;try{const o=(await s())?.[0]?.uid;if(!o)throw new Error("Failed to select card");for(let c=1;!n&&c>=0;c--)try{const s=[a,e][c];await l({block:t,isKb:c,key:s,uid:o}),await k({data:new r([160,t,...i])},{block:t,isKb:c,key:s,uid:o}),n=!0}catch(t){}if(!n)throw new Error(`Failed to write block ${t}`)}finally{await w()}},mfWriteCardByKeys:async function({sectorMax:a=16,keys:e,data:i}={}){if(!(e=y(e)).length)throw new TypeError("invalid keys");if(!r.isLen(i,64*a))throw new TypeError("invalid data");try{let n=(await s())?.[0]?.uid;if(!n)throw new Error("Failed to select card");const o=t.times(4*a,(()=>0));for(let t=0;t<a;t++){if(!d(i.subarray(64*t+54,64*t+57)))continue;let a=0;for(let c=1;4!==a&&c>=0;c--)for(const d of e)try{await l({block:4*t,isKb:c,key:d,uid:n});for(let e=0;e<4;e++)try{const l=4*t+e;if(o[l])continue;if(await k({data:new r([160,l,...i.subarray(16*l,16*l+16)])},{block:4*t,isKb:c,key:d,uid:n}),o[l]=1,a++,0===l&&(await w(),n=(await s())?.[0]?.uid,!n))throw new Error("Failed to select card")}catch(t){}break}catch(t){await w(),n=(await s())?.[0]?.uid}}return{success:o}}finally{await w()}},mfWriteCardGen1a:async function({sectorMax:a=16,data:e}={}){if(!r.isLen(e,64*a))throw new TypeError("invalid data");try{await b();const i=t.times(4*a,(()=>0));for(let t=0;t<a;t++)for(let a=0;a<4;a++)try{const n=4*t+a;await E({data:new r([160,n,...e.subarray(16*n,16*n+16)])}),i[n]=1}catch(t){}return{success:i}}finally{await w()}},mfWriteSector:async function({sector:t=0,isKb:a=0,key:e,data:i}={}){if(!r.isLen(i,64))throw new TypeError("invalid data");if(!d(i.subarray(54,57)))throw new TypeError("invalid sector acl");if(!r.isLen(e,6))throw new TypeError("invalid key");try{let n=(await s())?.[0]?.uid;if(!n)throw new Error("Failed to select card");await l({block:4*t,isKb:a,key:e,uid:n});const o=[0,0,0,0];for(let c=0;c<4;c++)try{const l=4*t+c;if(await k({data:new r([160,4*t+c,...i.subarray(16*c,16*c+16)])},{block:4*t,isKb:a,key:e,uid:n}),o[c]=1,0===l&&(await w(),n=(await s())?.[0]?.uid,!n))throw new Error("Failed to select card")}catch(t){}return{success:o}}finally{await w()}},mfWriteSectorGen1a:async function({sector:t=0,data:a}={}){if(!r.isLen(a,64))throw new TypeError("invalid data");if(!d(a.subarray(54,57)))throw new TypeError("invalid sector acl");try{await b();const e=[0,0,0,0];for(let i=0;i<4;i++)try{const n=4*t+i;await E({data:new r([160,n,...a.subarray(16*i,16*i+16)])}),e[i]=1}catch(t){}return{success:e}}finally{await w()}},mfWriteSectorKeyBA:async function({sector:t=0,ka:a,kb:e,data:i}={}){if(!r.isLen(i,64))throw new TypeError("invalid data");if(!d(i.subarray(54,57)))throw new TypeError("invalid sector acl");try{let n=(await s())?.[0]?.uid;if(!n)throw new Error("Failed to select card");const o=[0,0,0,0];for(let c=1;c>=0;c--)try{const d=[a,e][c];await l({block:4*t,isKb:c,key:d,uid:n});for(let a=0;a<4;a++)try{if(o[a])continue;const e=4*t+a;if(await k({data:new r([160,e,...i.subarray(16*a,16*a+16)])},{block:4*t,isKb:c,key:d,uid:n}),o[a]=1,0===e&&(await w(),n=(await s())?.[0]?.uid,!n))throw new Error("Failed to select card")}catch(t){}}catch(t){}return{success:o}}finally{await w()}},testIso14443Part4Present:async function(){let t=!1;return await o((async()=>{await i.inCommunicateThru({data:r.fromHex("B2")}),t=!0})),t}}}}}));
